
# JVM

1. java 가 OS 에 상관없이 동작할 수 있는 가상머신이다.
2. GC의 기능을 제공한다.

JVM 은 Java Virtue Machine 의 줄임말로
자바 웹 어플리케이션을 어느 CPU나 OS에 상관없이 실행될 수 있도록 역할을 수행합니다.

## 자바 어플리케이션이 실행과정

1. 어플리케이션이 실행되면 JVM은 OS로 부터 메모리를 할당받습니다.

2. 자바 컴파일러(javac.exe)가 우리가 작성하는 자바코드(.java)를 컴파일하여 바이트코드(.class)로 변환
3. 변환된 바이트코드(.class)를 ClassLoader를 통해 JVM 내 로딩 (객체들이 메모리로 올라오는 과정)
4. 로딩된 바이트코드는 실행엔진을 통해 해석이 된 후에
5. 해석된 바이트코드는 Runtime Data Areas 에 적재되어 실행됩니다.
6. 동시에 GC도 같이 수행됩니다.


## JVM은 크게 4가지로 구분됩니다.

- 클래스 로더(ClassLoader)
- 실행엔진(Excuse Engin)
- 런타임 데이터 에어리어(Runtime Data Area)
- JNI(Java Native Interface)


### 클래스로더

- 컴파일된 바이트코드를 클래스 로드 내 로드→링킹→이니셜라이저 거친 후 Runtime Data Areas에 배치 하는 작업을 수행합니다.
- 바이트코드를 메모리에 올리는 로딩 기능은, 한번에 메모리에 올리는 것이 아닌 어플리케이션 내 메소드 호출 시 동적으로 메모리에 적재됩니다.

### 실행엔진

- Runtime Data Areas 에 할당된 바이트코드를 실행하는 역할을 합니다.
- 코드를 실행하는 방식으로는 크게 2가지가 있으며
    - 인터프리터 방식
        - 바이트코드를 해석하여 실행하는 역할
        - 따라서 같은 메소드 호출 시 새로 수행해야 합니다.
    - Just In Time(JIT 컴파일러) 방식

      이를 보안하기 위해 나온 방식으로

        - 반복되는 코드를 바이트코드로 컴파일 한 후에 어셈블리어와 같은 Native 코드로 변환후에 빠르게 사용할 수 있다.
- GC

  또한, 실행엔진은 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 실행합니다.


### 런타임 데이터 에어리어(Runtime Data Areas)

- Rumtime Data Areas 는 실질적으로 OS로부터 메모리를 할당받아 관리되는 영역을 말하며


- Method Area

  static으로 선언된 변수를 포함하여, 상수 자료형, 클래스 레벨의 데이터가 저장됩니다.

- Heap Area

  new 연산자 생성된 오브젝트와 같은 동적인 메모리가 할당되는 곳입니다.
  인스턴스, 배열이 저장되는 곳으로 GC의 대상이 됩니다.
  물리적으로 에덴, 서바이버1, 서바이버2, 올드제너레이션 으로 구분됩니다.

    - eden

      모든 객체는 에덴으로 할당된 후, yeong generation 의 많은 minor GC를 거친 후 오래 사용되는 객체를 Old-Generation으로 이동하게됩니다.

    - serviver0
    - serviver1
    - Old-Generation

앞서, Method Area와 같이 Heap Area 는 여러 스레드 간 공유되는 메모리 입니다.

- Stack Area

  각 스레드의 런타임 스택 영역이며, 메소드 호출시 생성됩니다.
  따라서 지역변수, 파라미터 등 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장되며,
  메소드 종료 시 소멸됩니다.

- PC Register

  PC 는 Program Counter의 줄임말로 각 스레드가 시작될 때마다 하나씩 생성되며,
  현재 실행중인 상태정보를 저장하는 영역입니다.

  따라서, 스레드가 로직을 처리하면서 지속적으로 갱신됩니다.


- Native Method Stack

  Java가 아닌, 다른 언어로 작성된 코드를 위한 영역으로

  바이트코드가 아닌, 실제 실행될 수 있는 기계어로 작성된 프로그램을 실행킵니다.

  각 스레드 별로 생성


### JNI(Java Native Interface)

자바가 다른 언어로 만들어진 애플리케이션과 상호작용 할 수 있는 인터페이스 제공

JVM 이 Native 언어를 적재하고 수행할 수 있도록 함

이와 같이 JVM 은 용도에 따라 메모리를 할당하여 사용하며 자바 애플리케이션을 실행하게 됩니다.

## GC(가비지컬렉터)

GC는 자바의 메모리 관리 기법으로, Runtime Data Areas 내 힙 영역에서 더이상 참조하지 않는 객체의 메모리를 정해진 스케줄러에 의해 정리되는 것을 가비지 컬렉터라고 합니다.

GC의 종류로는

- Serial GC
- Parallel GC(패러럴)
- CMS GC
- G1 GC
- Z GC

일반적인 GC 과정

GC는 각 영역(힙)을 활용하여 최적의 메모리 운영을 하게 됨

1. 맨 처음 객체가 생성되면 에덴 영역에 저장된다.
2. Minor GC 가 발생하면, 미사용 객체 제거와 함께 사용되는 객체는 servivor0, serviver2 영역으로 이동시킴
3. 운영 특성 상, serviver0, serviver1 영역에 둘 중 한곳에만 존재하게끔 운영되며
4. 이 과정을 반복하면서 살아남은 객체들은 일정 스코어가 누적되면서 일정 기준치 이상이면 old-generation 영역으로 이동하게됩니다.(이를 프로모션이라고 하며)
5. old-generation 도 일정수준 쌓이게 되면 미사용 객체들을 제거하는 full-GC가 일어나게 되며

   이때, Stop-The-World 가 발생하게 됩니다.

   여기서 Stop-The-World는
   GC와 관련된 스레드를 제외한 JVM 내 모든 스레드가 멈추는 현상을 말합니다.


이와 같은 내용은 일반적으로 GC의 과정이라고 말씀드릴 수 있습니다.